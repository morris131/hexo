<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP粘包拆包]]></title>
    <url>%2Fposts%2Fcb3d31e9.html</url>
    <content type="text"><![CDATA[TCP粘包拆包TCP粘包是在一次接收数据不能完全地体现一个完整的消息数据。 TCP通讯为何存在粘包呢？主要原因是TCP是以流的方式来处理数据，再加上网络上MTU的往往小于在应用处理的消息数据，所以就会引发一次接收的数据无法满足消息的需要，导致粘包的存在。 问题演示serverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.morris.netty.frame.fail;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java123456789101112131415161718192021222324252627282930313233343536package com.morris.netty.frame.fail;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; private int count = 0; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from client: " + new String(bytes)); ctx.writeAndFlush(Unpooled.copiedBuffer(("hello client"+(++count)).getBytes())); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java1234567891011121314151617181920212223242526272829303132333435363738package com.morris.netty.frame.fail;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.morris.netty.frame.fail;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for(int i = 1 ; i &lt;= 5; i++) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(("hello"+i).getBytes())); &#125; &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from server: " + new String(bytes)); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 运行结果server12server is start on port: 8899receive from client: hello1hello2hello3hello4hello5 client1receive from server: hello client1 解决办法 消息定长，报文大小固定长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。 包尾添加特殊分隔符，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。 将消息分为消息头和消息体，消息头中包含表示信息的总长度（或者消息体长度）的字段。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DelimiterBasedFrameDecoder解决TCP粘包问题]]></title>
    <url>%2Fposts%2Fc8fb804a.html</url>
    <content type="text"><![CDATA[DelimiterBasedFrameDecoder解决TCP粘包问题发送方每条报文结束都添加特殊符号$作为报文分隔符，接收方通过特殊符号$切分报文区分。 解决方案serverServer.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.morris.netty.frame.delimiterbase;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.DelimiterBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1 &lt;&lt; 10, Unpooled.copiedBuffer("$_".getBytes()))); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java12345678910111213141516171819202122232425262728package com.morris.netty.frame.delimiterbase;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; int count = 1; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); ctx.writeAndFlush(Unpooled.copiedBuffer(("hello client" + (++count) + "$_").getBytes())); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.morris.netty.frame.delimiterbase;import io.netty.bootstrap.Bootstrap;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.DelimiterBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1 &lt;&lt; 10, Unpooled.copiedBuffer("$_".getBytes()))); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java123456789101112131415161718192021222324252627282930313233343536package com.morris.netty.frame.delimiterbase;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for(int i = 1 ; i &lt;= 5; i++) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(("hello" + i + "$_").getBytes())); &#125; &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 运行结果server123456server is start on port: 8899receive from client: hello1receive from client: hello2receive from client: hello3receive from client: hello4receive from client: hello5 client12345receive from server: hello client1receive from server: hello client2receive from server: hello client3receive from server: hello client4receive from server: hello client5]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf编解码]]></title>
    <url>%2Fposts%2F243adda.html</url>
    <content type="text"><![CDATA[protobuf编解码准备下载对应的protoc工具，用于生成实体类。 编写proto文件UserRequest.proto12345678syntax = &quot;proto3&quot;;option java_package = &quot;com.morris.netty.serialize.protobuf&quot;;option java_outer_classname = &quot;UserRequestProto&quot;;message UserRequest &#123; int32 age = 1; string name = 2;&#125; UserResponseProto.proto12345678syntax = &quot;proto3&quot;;option java_package = &quot;com.morris.netty.serialize.protobuf&quot;;option java_outer_classname = &quot;UserResponseProto&quot;;message UserResponse &#123; int32 code = 1; string message = 2;&#125; 用protoc.exe生成实体类，使用以下命令12protoc.exe --java_out=. UserRequest.protoprotoc.exe --java_out=. UserResponseProto.proto serverServer.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.morris.netty.serialize.protobuf;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;import io.netty.handler.codec.protobuf.ProtobufEncoder;import io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ProtobufVarint32FrameDecoder()); ch.pipeline().addLast(new ProtobufDecoder(UserRequestProto.UserRequest.getDefaultInstance())); ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender()); ch.pipeline().addLast(new ProtobufEncoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526package com.morris.netty.serialize.protobuf;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); UserResponseProto.UserResponse response = UserResponseProto.UserResponse.newBuilder().setCode(200).setMessage("success").buildPartial(); ctx.writeAndFlush(response); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.morris.netty.serialize.protobuf;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;import io.netty.handler.codec.protobuf.ProtobufEncoder;import io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ProtobufVarint32FrameDecoder()); ch.pipeline().addLast(new ProtobufDecoder(UserResponseProto.UserResponse.getDefaultInstance())); ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender()); ch.pipeline().addLast(new ProtobufEncoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java12345678910111213141516171819202122232425262728293031package com.morris.netty.serialize.protobuf;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; UserRequestProto.UserRequest request = UserRequestProto.UserRequest.newBuilder().setAge(18).setName("morris").buildPartial(); ctx.writeAndFlush(request); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; pojoUserRequestProto.java UserResponseProto.java 运行结果server123server is start on port: 8899receive from client: age: 18name: &quot;morris&quot; client12receive from server: code: 200message: &quot;success&quot;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编解码框架分析]]></title>
    <url>%2Fposts%2Ff252b055.html</url>
    <content type="text"><![CDATA[编解码框架分析编码（Encode）也称为序列化（serialization），它将对象序列化为字节数组，用于网络传输、数据持久化或者其它用途。 反之，解码（Decode）/ 反序列化（deserialization）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的拷贝），以方便后续的业务逻辑操作。 进行远程跨进程服务调用时（例如 RPC 调用），需要使用特定的编解码技术，对需要进行网络传输的对象做编码或者解码，以便完成远程调用。 常用的编解码框架Java 序列化Java 默认提供的序列化机制，需要序列化的 Java 对象只需要实现 java.io.Serializable 接口并生成序列化 ID，这个类就能够通过 java.io.ObjectInput 和 java.io.ObjectOutput 序列化和反序列化。 由于使用简单，开发门槛低，Java 序列化得到了广泛的应用，但是由于它自身存在很多缺点，因此大多数的 RPC 框架并没有选择它。Java 序列化的主要缺点如下： 无法跨语言：是 Java 序列化最致命的问题。对于跨进程的服务调用，服务提供者可能会使用 C++ 或者其它语言开发，当我们需要和异构语言进程交互时，Java 序列化就难以胜任。由于 Java 序列化技术是 Java 语言内部的私有协议，其它语言并不支持，对于用户来说它完全是黑盒。Java 序列化后的字节数组，别的语言无法进行反序列化，这就严重阻碍了它的应用范围； 序列化后的码流太大: 例如使用二进制编解码技术对同一个复杂的 POJO 对象进行编码，它的码流仅仅为 Java 序列化之后的 20% 左右；目前主流的编解码框架，序列化之后的码流都远远小于原生的 Java 序列化； 序列化效率差：在相同的硬件条件下、对同一个 POJO 对象做 100W 次序列化，二进制编码和 Java 原生序列化的性能对比测试如下图所示：Java 原生序列化的耗时是二进制编码的 16.2 倍，效率非常差。 Google 的 ProtobufProtobuf 全称 Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。 它的特点如下： 结构化数据存储格式（XML，JSON 等）； 高效的编解码性能； 语言无关、平台无关、扩展性好； 官方支持 Java、C++ 和 Python 三种语言。 JBoss MarshallingJBoss Marshalling 是一个 Java 对象的序列化 API 包，修正了 JDK 自带的序列化包的很多问题，但又保持跟 java.io.Serializable 接口的兼容；同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。 相比于传统的 Java 序列化机制，它的优点如下： 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制； 可插拔的对象替换技术，不需要通过继承的方式； 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能； 无须实现 java.io.Serializable 接口，即可实现 Java 序列化； 通过缓存技术提升对象的序列化性能。 相比于前面介绍的两种编解码框架，JBoss Marshalling 更多是在 JBoss 内部使用，应用范围有限。 其它编解码框架除了上述介绍的编解码框架和技术之外，比较常用的还有 MessagePack、kryo、hession 和 Json 等。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LineBasedFrameDecoder解决TCP粘包问题]]></title>
    <url>%2Fposts%2F94b04655.html</url>
    <content type="text"><![CDATA[LineBasedFrameDecoder解决TCP粘包问题发送方每条报文结束都添加回车换行符作为报文分隔符，接收方通过回车换行符切分报文区分。 解决方案serverServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.morris.netty.frame.linebase;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new LineBasedFrameDecoder(1 &lt;&lt; 10)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526272829package com.morris.netty.frame.linebase;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; private int count = 0; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); ctx.writeAndFlush(Unpooled.copiedBuffer(("hello client" + (++count) + "\n").getBytes())); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.morris.netty.frame.linebase;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new LineBasedFrameDecoder(1 &lt;&lt; 10)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java123456789101112131415161718192021222324252627282930313233343536package com.morris.netty.frame.linebase;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for(int i = 1 ; i &lt;= 5; i++) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(("hello" + i + "\n").getBytes())); &#125; &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 运行结果server123456server is start on port: 8899receive from client: hello1receive from client: hello2receive from client: hello3receive from client: hello4receive from client: hello5 client12345receive from server: hello client1receive from server: hello client2receive from server: hello client3receive from server: hello client4receive from server: hello client5]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FixedLengthFrameDecoder解决TCP粘包问题]]></title>
    <url>%2Fposts%2F8f9957ac.html</url>
    <content type="text"><![CDATA[FixedLengthFrameDecoder解决TCP粘包问题发送方每条报文长度均为16个字节，接收方通过16个字节长度切分报文区分。 解决方案serverServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.morris.netty.frame.fixlength;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.FixedLengthFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new FixedLengthFrameDecoder(16)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(8899).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java12345678910111213141516171819202122232425262728293031package com.morris.netty.frame.fixlength;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; int count = 1; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); ctx.writeAndFlush(Unpooled.copiedBuffer(("hello client" + (++count) + " ").getBytes())); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.morris.netty.frame.fixlength;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.FixedLengthFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new FixedLengthFrameDecoder(16)); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java123456789101112131415161718192021222324252627282930313233343536package com.morris.netty.frame.fixlength;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for(int i = 1 ; i &lt;= 5; i++) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(("hello" + i + " ").getBytes())); &#125; &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 运行结果server123456server is start on port: 8899receive from client: hello1receive from client: hello2receive from client: hello3receive from client: hello4receive from client: hello5 client12345receive from server: hello client1receive from server: hello client2receive from server: hello client3receive from server: hello client4receive from server: hello client5]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Marshalling编解码]]></title>
    <url>%2Fposts%2F60d98196.html</url>
    <content type="text"><![CDATA[Marshalling编解码serverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.morris.netty.serialize.marshalling;import com.morris.netty.serialize.java.ServerHandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) //.handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.java;import com.morris.netty.serialize.pojo.UserResponse;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); UserResponse response = new UserResponse(); response.setCode(200); response.setMessage("success"); ctx.writeAndFlush(response); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.morris.netty.serialize.marshalling;import com.morris.netty.serialize.java.ClientHandler;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder()); ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java12345678910111213141516171819202122232425262728293031323334353637package com.morris.netty.serialize.java;import com.morris.netty.serialize.pojo.UserRequest;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; UserRequest request = new UserRequest(); request.setAge(18); request.setName("morris"); ctx.writeAndFlush(request); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; fatoryMarshallingCodeCFactory.java12345678910111213141516171819202122232425262728package com.morris.netty.serialize.marshalling;import io.netty.handler.codec.marshalling.*;import org.jboss.marshalling.MarshallerFactory;import org.jboss.marshalling.Marshalling;import org.jboss.marshalling.MarshallingConfiguration;public final class MarshallingCodeCFactory &#123; public static MarshallingDecoder buildMarshallingDecoder() &#123; final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial"); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration); MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024); return decoder; &#125; public static MarshallingEncoder buildMarshallingEncoder() &#123; final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial"); final MarshallingConfiguration configuration = new MarshallingConfiguration(); configuration.setVersion(5); MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration); MarshallingEncoder encoder = new MarshallingEncoder(provider); return encoder; &#125;&#125; pojoUserRequest.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.pojo;import java.io.Serializable;public class UserRequest implements Serializable &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "UserRequest&#123;" + "age=" + age + ", name='" + name + '\'' + '&#125;'; &#125;&#125; UserResponse.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.pojo;import java.io.Serializable;public class UserResponse implements Serializable &#123; private int code; private String message; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; @Override public String toString() &#123; return "UserResponse&#123;" + "code=" + code + ", message='" + message + '\'' + '&#125;'; &#125;&#125; 运行结果server12server is start on port: 8899receive from client: UserRequest&#123;age=18, name=&apos;morris&apos;&#125; client1receive from server: UserResponse&#123;code=200, message=&apos;success&apos;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2Fposts%2F9cd1a944.html</url>
    <content type="text"><![CDATA[Java序列化serverServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.morris.netty.serialize.java;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.FixedLengthFrameDecoder;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import io.netty.handler.codec.string.StringDecoder;public class Server &#123; public static final int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ObjectDecoder(1024 * 1024, ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader()))); ch.pipeline().addLast(new ObjectEncoder()); ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.java;import com.morris.netty.serialize.pojo.UserResponse;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from client: " + msg); UserResponse response = new UserResponse(); response.setCode(200); response.setMessage("success"); ctx.writeAndFlush(response); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.morris.netty.serialize.java;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.FixedLengthFrameDecoder;import io.netty.handler.codec.serialization.ClassResolver;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;import io.netty.handler.codec.string.StringDecoder;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ObjectDecoder(1024, ClassResolvers.weakCachingResolver(this.getClass().getClassLoader()))); ch.pipeline().addLast(new ObjectEncoder()); ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java12345678910111213141516171819202122232425262728293031323334353637package com.morris.netty.serialize.java;import com.morris.netty.serialize.pojo.UserRequest;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; UserRequest request = new UserRequest(); request.setAge(18); request.setName("morris"); ctx.writeAndFlush(request); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; System.out.println("receive from server: " + msg); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; pojoUserRequest.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.pojo;import java.io.Serializable;public class UserRequest implements Serializable &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "UserRequest&#123;" + "age=" + age + ", name='" + name + '\'' + '&#125;'; &#125;&#125; UserResponse.java12345678910111213141516171819202122232425262728293031323334package com.morris.netty.serialize.pojo;import java.io.Serializable;public class UserResponse implements Serializable &#123; private int code; private String message; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; @Override public String toString() &#123; return "UserResponse&#123;" + "code=" + code + ", message='" + message + '\'' + '&#125;'; &#125;&#125; 运行结果server12server is start on port: 8899receive from client: UserRequest&#123;age=18, name=&apos;morris&apos;&#125; client1receive from server: UserResponse&#123;code=200, message=&apos;success&apos;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIO]]></title>
    <url>%2Fposts%2F49c196a8.html</url>
    <content type="text"><![CDATA[AIO与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 serverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.morris.aio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class Server &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(1); AsynchronousServerSocketChannel asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open(); asynchronousServerSocketChannel.bind(new InetSocketAddress(8899)); asynchronousServerSocketChannel.accept(asynchronousServerSocketChannel, new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123; @Override public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) &#123; attachment.accept(attachment, this); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); result.read(byteBuffer, result , new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; byteBuffer.flip(); // read byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); System.out.println("receive from client: " + new String(bytes)); // write ByteBuffer resultBuf = ByteBuffer.wrap("hello client".getBytes()); attachment.write(resultBuf, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) &#123; &#125; &#125;); System.out.println("server is start on port: 8899"); countDownLatch.await(); &#125;&#125; clientClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.morris.aio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class Client &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(1); AsynchronousSocketChannel asynchronousServerSocketChannel = AsynchronousSocketChannel.open(); asynchronousServerSocketChannel.connect(new InetSocketAddress("127.0.0.1", 8899), asynchronousServerSocketChannel, new CompletionHandler&lt;Void, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Void result, AsynchronousSocketChannel attachment) &#123; ByteBuffer resultBuf = ByteBuffer.wrap("hello server".getBytes()); attachment.write(resultBuf, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); attachment.read(byteBuffer, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String body = new String(bytes); System.out.println("receive from server: " + body); countDownLatch.countDown(); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); countDownLatch.await(); &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>AIO</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty helloworld]]></title>
    <url>%2Fposts%2F28519d34.html</url>
    <content type="text"><![CDATA[netty helloworldserverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.morris.netty.basic;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526272829303132333435package com.morris.netty.basic;import io.netty.buffer.ByteBuf;import io.netty.buffer.ByteBufUtil;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from client: " + new String(bytes)); ByteBuf sendByteBuf = Unpooled.copiedBuffer("hello client".getBytes()); ctx.writeAndFlush(sendByteBuf); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java1234567891011121314151617181920212223242526272829303132333435363738package com.morris.netty.basic;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.morris.netty.basic;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ByteBuf sendByteBuf = Unpooled.copiedBuffer("hello server".getBytes()); ctx.writeAndFlush(sendByteBuf); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from server: " + new String(bytes)); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO]]></title>
    <url>%2Fposts%2F429dd195.html</url>
    <content type="text"><![CDATA[NIONIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。 在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。 BufferBuffer其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。 所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer。 ChannelChannel是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。 Selector通道和缓冲区的机制，使得线程无需阻塞地等待IO事件的就绪，但是总是要有人来监管这些IO事件。这个工作就交给了selector来完成，这就是所谓的同步。 Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。 要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪，这就是所说的轮询。一旦这个方法返回，线程就可以处理这些事件。 Selector中注册的感兴趣事件有： OP_ACCEPT OP_CONNECT OP_READ OP_WRITE serverServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.morris.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); // 设置为非阻塞方式 serverSocketChannel.socket().bind(new InetSocketAddress(PORT)); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册监听的事件 System.out.println("server is start on port: " + PORT); while (true) &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator(); while (selectionKeyIterator.hasNext()) &#123; SelectionKey key = selectionKeyIterator.next(); selectionKeyIterator.remove(); if(key.isValid()) &#123; if(key.isAcceptable())&#123; ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel(); SocketChannel sc = ssChannel.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ); &#125; if(key.isReadable())&#123; SocketChannel sc = (SocketChannel)key.channel(); ByteBuffer buf = ByteBuffer.allocate(1024); int bytesRead = sc.read(buf); if(bytesRead &gt; 0)&#123; buf.flip(); byte[] bytes = new byte[buf.remaining()]; buf.get(bytes); String body = new String(bytes); System.out.println("receive from client: " + body); String response = "hello client"; bytes = response.getBytes(); buf = ByteBuffer.allocate(bytes.length); buf.put(bytes); buf.flip(); sc.write(buf); key.cancel(); sc.close(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.morris.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;public class Client &#123; public static int PORT = 8899; private static volatile boolean stop = true; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); SocketChannel serverSocketChannel = SocketChannel.open(); serverSocketChannel.configureBlocking(false); // 设置为非阻塞方式 boolean connect = serverSocketChannel.connect(new InetSocketAddress("127.0.0.1", PORT)); if (connect) &#123; serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册监听的事件 &#125; else &#123; serverSocketChannel.register(selector, SelectionKey.OP_CONNECT); // 注册监听的事件 &#125; while (stop) &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator(); while (selectionKeyIterator.hasNext()) &#123; SelectionKey key = selectionKeyIterator.next(); selectionKeyIterator.remove(); if (key.isValid()) &#123; SocketChannel sc = (SocketChannel) key.channel(); if (key.isConnectable()) &#123; if (sc.finishConnect()) &#123; sc.register(selector, SelectionKey.OP_READ); String response = "hello server"; byte[] bytes = response.getBytes(); ByteBuffer buf = ByteBuffer.allocate(bytes.length); buf.put(bytes); buf.flip(); sc.write(buf); &#125; &#125; if (key.isReadable()) &#123; ByteBuffer buf = ByteBuffer.allocate(1024); int bytesRead = sc.read(buf); if (bytesRead &gt; 0) &#123; buf.flip(); byte[] bytes = new byte[buf.remaining()]; buf.get(bytes); String body = new String(bytes); System.out.println("receive from server: " + body); key.cancel(); sc.close(); stop = false; &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪异步IO]]></title>
    <url>%2Fposts%2F66487d6f.html</url>
    <content type="text"><![CDATA[伪异步IO伪异步IO只是用线程池管理BIO中的线程,其他代码与BIO一致。 serverFakeBIOServer.java12345678910111213141516171819202122232425262728293031package com.morris.fakebio;import com.morris.bio.ServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class FakeBIOServer &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(PORT); System.out.println("server is start on port: " + PORT); ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1000)); while (true) &#123; Socket socket = serverSocket.accept(); executorService.execute(new ServerHandler(socket)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO]]></title>
    <url>%2Fposts%2F4b8728f1.html</url>
    <content type="text"><![CDATA[BIOserverServer.java1234567891011121314151617181920212223package com.morris.bio;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(PORT); System.out.println("server is start on port: " + PORT); while (true) &#123; Socket socket = serverSocket.accept(); new Thread(new ServerHandler(socket)).start(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.morris.bio;import java.io.*;import java.net.Socket;import java.nio.channels.NonReadableChannelException;public class ServerHandler implements Runnable &#123; private Socket socket; public ServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; PrintWriter printWriter = null; BufferedReader bufferedReader = null; try &#123; // 读取数据 bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = null; //while (true) &#123; line = bufferedReader.readLine(); System.out.println("receive message from client: " + line); // 发送数据 printWriter = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true); printWriter.println("hello client"); //&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != bufferedReader) &#123; try &#123; bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null != printWriter) &#123; printWriter.close(); &#125; if(null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; clientClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.morris.bio;import java.io.*;import java.net.Socket;public class Client &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket("127.0.0.1", 8899); PrintWriter printWriter = null; BufferedReader bufferedReader = null; try &#123; bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 发送数据 printWriter = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true); printWriter.println("hello server"); // 读取数据 String line = null; while (null != (line = bufferedReader.readLine())) &#123; System.out.println("receive message from server: " + line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != printWriter) &#123; printWriter.close(); &#125; if(null != bufferedReader) &#123; try &#123; bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>BIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种IO的比较]]></title>
    <url>%2Fposts%2Fcde0db97.html</url>
    <content type="text"><![CDATA[四种IO的比较名词解释同步和异步是针对应用程序和内核的交互而言的。 阻塞和非阻塞是针对于进程在访问数据的时候。 同步 ：用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪 异步 ：用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 阻塞 ：当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 比较 不选择JAVA原生NIO编程的原因 NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等； 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序； 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大； JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。 为什么选择Netty API使用简单，开发门槛低； 功能强大，预置了多种编解码功能，支持多种主流协议； 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展； 性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优； 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼； 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入； 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。 为什么Netty使用NIO而不是AIO？ Netty不看重Windows上的使用，在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化 Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成reactor模型看起来是把epoll绕个弯又绕回来 AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多 Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git设置mergetool可视化工具BeyondCompare]]></title>
    <url>%2Fposts%2F3765ef4c.html</url>
    <content type="text"><![CDATA[可以设置BeyondCompare作为git的比较和合并的可视化工具,方便操作.设置如下: 先下载并安装BeyondCompare 命令输入如下配置1234567891011#difftool 配置git config --global diff.tool bc4git config --global difftool.bc4.cmd &quot;\&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;#mergeftool 配置git config --global merge.tool bc4git config --global mergetool.bc4.cmd &quot;\&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;git config --global mergetool.bc4.trustExitCode true#让git mergetool不再生成备份文件（*.orig）git config --global mergetool.keepBackup false 若未生效，直接修改用户目录下.gitconfig文件1234567891011[diff] tool = bc4[difftool &quot;bc4&quot;] cmd = \&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;[merge] tool = bc4[mergetool &quot;bc4&quot;] cmd = \&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot; trustExitCode = true[mergetool] keepBackup = false 使用方法如下:12345# diff使用方法:git difftool HEAD // 比较当前修改情况# merge使用方法# git mergetool]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>mergetool</tag>
        <tag>BeyondCompare</tag>
      </tags>
  </entry>
</search>
