<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AIO]]></title>
    <url>%2Fposts%2F49c196a8.html</url>
    <content type="text"><![CDATA[AIO与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 serverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.morris.aio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class Server &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(1); AsynchronousServerSocketChannel asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open(); asynchronousServerSocketChannel.bind(new InetSocketAddress(8899)); asynchronousServerSocketChannel.accept(asynchronousServerSocketChannel, new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123; @Override public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) &#123; attachment.accept(attachment, this); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); result.read(byteBuffer, result , new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; byteBuffer.flip(); // read byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); System.out.println("receive from client: " + new String(bytes)); // write ByteBuffer resultBuf = ByteBuffer.wrap("hello client".getBytes()); attachment.write(resultBuf, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) &#123; &#125; &#125;); System.out.println("server is start on port: 8899"); countDownLatch.await(); &#125;&#125; clientClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.morris.aio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.CountDownLatch;public class Client &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(1); AsynchronousSocketChannel asynchronousServerSocketChannel = AsynchronousSocketChannel.open(); asynchronousServerSocketChannel.connect(new InetSocketAddress("127.0.0.1", 8899), asynchronousServerSocketChannel, new CompletionHandler&lt;Void, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Void result, AsynchronousSocketChannel attachment) &#123; ByteBuffer resultBuf = ByteBuffer.wrap("hello server".getBytes()); attachment.write(resultBuf, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); attachment.read(byteBuffer, attachment, new CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt;() &#123; @Override public void completed(Integer result, AsynchronousSocketChannel attachment) &#123; byteBuffer.flip(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); String body = new String(bytes); System.out.println("receive from server: " + body); countDownLatch.countDown(); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsynchronousSocketChannel attachment) &#123; &#125; &#125;); countDownLatch.await(); &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>AIO</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIO]]></title>
    <url>%2Fposts%2F4b8728f1.html</url>
    <content type="text"><![CDATA[BIOserverServer.java1234567891011121314151617181920212223package com.morris.bio;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(PORT); System.out.println("server is start on port: " + PORT); while (true) &#123; Socket socket = serverSocket.accept(); new Thread(new ServerHandler(socket)).start(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.morris.bio;import java.io.*;import java.net.Socket;import java.nio.channels.NonReadableChannelException;public class ServerHandler implements Runnable &#123; private Socket socket; public ServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; PrintWriter printWriter = null; BufferedReader bufferedReader = null; try &#123; // 读取数据 bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = null; //while (true) &#123; line = bufferedReader.readLine(); System.out.println("receive message from client: " + line); // 发送数据 printWriter = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true); printWriter.println("hello client"); //&#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != bufferedReader) &#123; try &#123; bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null != printWriter) &#123; printWriter.close(); &#125; if(null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; clientClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.morris.bio;import java.io.*;import java.net.Socket;public class Client &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket("127.0.0.1", 8899); PrintWriter printWriter = null; BufferedReader bufferedReader = null; try &#123; bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 发送数据 printWriter = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true); printWriter.println("hello server"); // 读取数据 String line = null; while (null != (line = bufferedReader.readLine())) &#123; System.out.println("receive message from server: " + line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null != printWriter) &#123; printWriter.close(); &#125; if(null != bufferedReader) &#123; try &#123; bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>BIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO]]></title>
    <url>%2Fposts%2F429dd195.html</url>
    <content type="text"><![CDATA[NIONIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。 在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。 BufferBuffer其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。 所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer。 ChannelChannel是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。 Selector通道和缓冲区的机制，使得线程无需阻塞地等待IO事件的就绪，但是总是要有人来监管这些IO事件。这个工作就交给了selector来完成，这就是所谓的同步。 Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。 要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪，这就是所说的轮询。一旦这个方法返回，线程就可以处理这些事件。 Selector中注册的感兴趣事件有： OP_ACCEPT OP_CONNECT OP_READ OP_WRITE serverServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.morris.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); // 设置为非阻塞方式 serverSocketChannel.socket().bind(new InetSocketAddress(PORT)); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册监听的事件 System.out.println("server is start on port: " + PORT); while (true) &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator(); while (selectionKeyIterator.hasNext()) &#123; SelectionKey key = selectionKeyIterator.next(); selectionKeyIterator.remove(); if(key.isValid()) &#123; if(key.isAcceptable())&#123; ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel(); SocketChannel sc = ssChannel.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ); &#125; if(key.isReadable())&#123; SocketChannel sc = (SocketChannel)key.channel(); ByteBuffer buf = ByteBuffer.allocate(1024); int bytesRead = sc.read(buf); if(bytesRead &gt; 0)&#123; buf.flip(); byte[] bytes = new byte[buf.remaining()]; buf.get(bytes); String body = new String(bytes); System.out.println("receive from client: " + body); String response = "hello client"; bytes = response.getBytes(); buf = ByteBuffer.allocate(bytes.length); buf.put(bytes); buf.flip(); sc.write(buf); key.cancel(); sc.close(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; clientClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.morris.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;public class Client &#123; public static int PORT = 8899; private static volatile boolean stop = true; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); SocketChannel serverSocketChannel = SocketChannel.open(); serverSocketChannel.configureBlocking(false); // 设置为非阻塞方式 boolean connect = serverSocketChannel.connect(new InetSocketAddress("127.0.0.1", PORT)); if (connect) &#123; serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册监听的事件 &#125; else &#123; serverSocketChannel.register(selector, SelectionKey.OP_CONNECT); // 注册监听的事件 &#125; while (stop) &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator(); while (selectionKeyIterator.hasNext()) &#123; SelectionKey key = selectionKeyIterator.next(); selectionKeyIterator.remove(); if (key.isValid()) &#123; SocketChannel sc = (SocketChannel) key.channel(); if (key.isConnectable()) &#123; if (sc.finishConnect()) &#123; sc.register(selector, SelectionKey.OP_READ); String response = "hello server"; byte[] bytes = response.getBytes(); ByteBuffer buf = ByteBuffer.allocate(bytes.length); buf.put(bytes); buf.flip(); sc.write(buf); &#125; &#125; if (key.isReadable()) &#123; ByteBuffer buf = ByteBuffer.allocate(1024); int bytesRead = sc.read(buf); if (bytesRead &gt; 0) &#123; buf.flip(); byte[] bytes = new byte[buf.remaining()]; buf.get(bytes); String body = new String(bytes); System.out.println("receive from server: " + body); key.cancel(); sc.close(); stop = false; &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty helloworld]]></title>
    <url>%2Fposts%2F28519d34.html</url>
    <content type="text"><![CDATA[netty helloworldserverServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.morris.netty.basic;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class Server &#123; public static int PORT = 8899; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ServerHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.bind(PORT).sync(); System.out.println("server is start on port: " + PORT); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java1234567891011121314151617181920212223242526272829303132333435package com.morris.netty.basic;import io.netty.buffer.ByteBuf;import io.netty.buffer.ByteBufUtil;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ServerHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from client: " + new String(bytes)); ByteBuf sendByteBuf = Unpooled.copiedBuffer("hello client".getBytes()); ctx.writeAndFlush(sendByteBuf); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; clientClient.java1234567891011121314151617181920212223242526272829303132333435363738package com.morris.netty.basic;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ClientHandler()); &#125; &#125;); // 启动 server. ChannelFuture f = b.connect("127.0.0.1", 8899).sync(); // 等待socket关闭 f.channel().closeFuture().sync(); &#125; finally &#123; workerGroup.shutdownGracefully(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.morris.netty.basic;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.util.ReferenceCountUtil;public class ClientHandler extends ChannelHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ByteBuf sendByteBuf = Unpooled.copiedBuffer("hello server".getBytes()); ctx.writeAndFlush(sendByteBuf); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; try &#123; ByteBuf receiveByteBuf = (ByteBuf) msg; byte[] bytes = new byte[receiveByteBuf.readableBytes()]; receiveByteBuf.readBytes(bytes); System.out.println("receive from server: " + new String(bytes)); ctx.close(); &#125; finally &#123; ReferenceCountUtil.release(msg); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪异步IO]]></title>
    <url>%2Fposts%2F66487d6f.html</url>
    <content type="text"><![CDATA[伪异步IO伪异步IO只是用线程池管理BIO中的线程,其他代码与BIO一致。 serverFakeBIOServer.java12345678910111213141516171819202122232425262728293031package com.morris.fakebio;import com.morris.bio.ServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class FakeBIOServer &#123; public static int PORT = 8899; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(PORT); System.out.println("server is start on port: " + PORT); ExecutorService executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1000)); while (true) &#123; Socket socket = serverSocket.accept(); executorService.execute(new ServerHandler(socket)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种IO的比较]]></title>
    <url>%2Fposts%2Fcde0db97.html</url>
    <content type="text"><![CDATA[四种IO的比较名词解释同步和异步是针对应用程序和内核的交互而言的。 阻塞和非阻塞是针对于进程在访问数据的时候。 同步 ：用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪 异步 ：用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 阻塞 ：当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 比较 不选择JAVA原生NIO编程的原因 NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等； 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序； 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大； JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。 为什么选择Netty API使用简单，开发门槛低； 功能强大，预置了多种编解码功能，支持多种主流协议； 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展； 性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优； 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼； 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入； 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。 为什么Netty使用NIO而不是AIO？ Netty不看重Windows上的使用，在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化 Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成reactor模型看起来是把epoll绕个弯又绕回来 AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多 Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git设置mergetool可视化工具BeyondCompare]]></title>
    <url>%2Fposts%2F3765ef4c.html</url>
    <content type="text"><![CDATA[可以设置BeyondCompare作为git的比较和合并的可视化工具,方便操作.设置如下: 先下载并安装BeyondCompare 命令输入如下配置1234567891011#difftool 配置git config --global diff.tool bc4git config --global difftool.bc4.cmd &quot;\&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;#mergeftool 配置git config --global merge.tool bc4git config --global mergetool.bc4.cmd &quot;\&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;git config --global mergetool.bc4.trustExitCode true#让git mergetool不再生成备份文件（*.orig）git config --global mergetool.keepBackup false 若未生效，直接修改用户目录下.gitconfig文件1234567891011[diff] tool = bc4[difftool &quot;bc4&quot;] cmd = \&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;[merge] tool = bc4[mergetool &quot;bc4&quot;] cmd = \&quot;C:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot; trustExitCode = true[mergetool] keepBackup = false 使用方法如下:12345# diff使用方法:git difftool HEAD // 比较当前修改情况# merge使用方法# git mergetool]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>mergetool</tag>
        <tag>BeyondCompare</tag>
      </tags>
  </entry>
</search>
